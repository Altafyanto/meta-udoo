From 1b23a8c02d7ec0118e7bd8803e0284b51d670fa8 Mon Sep 17 00:00:00 2001
From: root <root@static.212.40.4.46.clients.your-server.de>
Date: Mon, 10 Oct 2016 21:21:38 +0200
Subject: [PATCH] Added preliminary eMMC support for Seco A62

Signed-off-by: Christian Ege <k4230r6@gmail.com>
---
 board/seco/mx6sbca62/mx6sbca62.c | 160 ++++++++++++++++++++++++++++++++++-----
 include/configs/secomx6sbca62.h  |   1 +
 2 files changed, 142 insertions(+), 19 deletions(-)

diff --git a/board/seco/mx6sbca62/mx6sbca62.c b/board/seco/mx6sbca62/mx6sbca62.c
index b8efedc..5ff4596 100644
--- a/board/seco/mx6sbca62/mx6sbca62.c
+++ b/board/seco/mx6sbca62/mx6sbca62.c
@@ -63,13 +63,38 @@ static iomux_v3_cfg_t const uart2_pads[] = {
 	IOMUX_PADS(PAD_EIM_D27__UART2_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
 };
 
-static iomux_v3_cfg_t const usdhc3_pads[] = {
-	IOMUX_PADS(PAD_SD3_CLK__SD3_CLK    | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
-	IOMUX_PADS(PAD_SD3_CMD__SD3_CMD    | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
-	IOMUX_PADS(PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
-	IOMUX_PADS(PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
-	IOMUX_PADS(PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
-	IOMUX_PADS(PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+/*  __________________________________________________________________________
+ * |                                                                          |
+ * |	                         ON BOARD uSD		                      |
+ * |__________________________________________________________________________|
+ */
+iomux_v3_cfg_t const usdhc3_pads[] = {
+	IOMUX_PADS(PAD_SD3_CLK__SD3_CLK     | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_CMD__SD3_CMD     | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT0__SD3_DATA0  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT1__SD3_DATA1  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT2__SD3_DATA2  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT3__SD3_DATA3  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT5__GPIO7_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL)),     // CD
+	IOMUX_PADS(PAD_NANDF_D5__GPIO2_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)),     // PWR
+};
+
+/*  __________________________________________________________________________
+ * |                                                                          |
+ * |		                      eMMC		                      |
+ * |__________________________________________________________________________|
+ */
+iomux_v3_cfg_t const usdhc4_pads[] = {
+	IOMUX_PADS(PAD_SD4_CLK__SD4_CLK     | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_CMD__SD4_CMD     | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT0__SD4_DATA0  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT1__SD4_DATA1  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT2__SD4_DATA2  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT3__SD4_DATA3  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT4__SD4_DATA4  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT5__SD4_DATA5  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT6__SD4_DATA6  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT7__SD4_DATA7  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
 };
 
 static iomux_v3_cfg_t const wdog_pads[] = {
@@ -242,12 +267,117 @@ static void setup_iomux_wdog(void)
 	gpio_direction_input(WDT_TRG);
 }
 
-static struct fsl_esdhc_cfg usdhc_cfg = { USDHC3_BASE_ADDR };
 
-int board_mmc_getcd(struct mmc *mmc)
-{
-	return 1; /* Always present */
+/*  __________________________________________________________________________
+ * |                                                                          |
+ * |                                   USDHC                                  |
+ * |__________________________________________________________________________|
+ */
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(7, 0)
+#define USDHC3_PWR_GPIO IMX_GPIO_NR(2, 5)
+
+/* USDHC map:
+ * 	USDHC4  -->  eMMC  -->  FSL_SDHC: 0
+ * 	USDHC3  -->  uSD   -->  FSL_SDHC: 1
+ */
+
+struct fsl_esdhc_cfg usdhc_cfg[CONFIG_SYS_FSL_USDHC_NUM] = {
+	{USDHC3_BASE_ADDR, 0, 4},
+	{USDHC4_BASE_ADDR, 0, 8},
+};
+
+enum mxc_clock usdhc_clk[CONFIG_SYS_FSL_USDHC_NUM] = {
+	MXC_ESDHC4_CLK,
+	MXC_ESDHC3_CLK,
+};
+
+/* map the usdhc controller id to the devno given to the board device */
+int usdhc_devno[4] = { -1, -1, 1, 0};
+
+int board_mmc_getcd (struct mmc *mmc) {
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+		case USDHC3_BASE_ADDR:
+			ret = !gpio_get_value(USDHC3_CD_GPIO);
+			break;
+		case USDHC4_BASE_ADDR:
+			ret = 1; /* eMMC/uSDHC4 is always present */
+			break;
+	}
+
+	return ret;
+}
+
+int check_mmc_autodetect (void) {
+	char *autodetect_str = getenv ("mmcautodetect");
+
+	if ( (autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0) ) {
+		return 1;
+	}
+
+	return 0;
+}
+
+int board_mmc_init(bd_t *bis){
+#ifndef CONFIG_SPL_BUILD
+	int ret;
+	int i;
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			SETUP_IOMUX_PADS(usdhc4_pads);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;			
+		case 1:
+			SETUP_IOMUX_PADS(usdhc3_pads);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);		
+			gpio_direction_input(USDHC3_CD_GPIO);
+			gpio_direction_output(USDHC3_PWR_GPIO, 1);
+			break;
+			
+		default:
+			printf("Warning: you configured more USDHC controllers"
+			       "(%d) then supported by the board (%d)\n",
+			       i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+#else
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	unsigned reg_smbr1 = readl(&psrc->sbmr1);
+	unsigned reg = readl(&psrc->sbmr1) >> 11;	
+
+	printf("mmc port %d\n", reg & 0x3);
+
+	if ((reg_smbr1 & 0x0820) == 0x0820) {
+	   /* Setup eMMC */
+	   SETUP_IOMUX_PADS(usdhc4_pads);
+	   usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+	   return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+	} else {
+	   /* Setup uSD */
+	   SETUP_IOMUX_PADS(usdhc3_pads);
+	   usdhc_cfg[1].esdhc_base = USDHC3_BASE_ADDR;
+	   usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+	   gpio_direction_input(USDHC3_CD_GPIO);
+	   gpio_direction_output(USDHC3_PWR_GPIO, 1);
+	   gd->arch.sdhc_clk = usdhc_cfg[1].sdhc_clk;
+	   return fsl_esdhc_initialize(bis, &usdhc_cfg[1]);
+	}
+#endif
 }
+#endif /*  CONFIG_FSL_ESDHC  */
 
 int board_eth_init(bd_t *bis)
 {
@@ -283,14 +413,6 @@ free_bus:
 	return ret;
 }
 
-int board_mmc_init(bd_t *bis)
-{
-	SETUP_IOMUX_PADS(usdhc3_pads);
-	usdhc_cfg.sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
-	usdhc_cfg.max_bus_width = 4;
-
-	return fsl_esdhc_initialize(bis, &usdhc_cfg);
-}
 
 int board_early_init_f(void)
 {
diff --git a/include/configs/secomx6sbca62.h b/include/configs/secomx6sbca62.h
index 5767b40..c44cbd1 100644
--- a/include/configs/secomx6sbca62.h
+++ b/include/configs/secomx6sbca62.h
@@ -83,6 +83,7 @@
 #define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 500 * SZ_1M)
 
 /* MMC Configuration */
+#define CONFIG_SYS_FSL_USDHC_NUM 2
 #define CONFIG_SYS_FSL_ESDHC_ADDR	0
 
 #define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
-- 
2.1.4

